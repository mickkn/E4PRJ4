\subsection*{Cross Compiler}

\textit{For at gøre udviklingsprocessen hurtigere og for at kunne debugge koden blev der tidligt i forløbet lavet et ønske om at kunne krydskompilerer til Raspberry Pi (Raspbian OS). Det har ikke været uden en del problemer, da der i starten gerne ville kunne kodes fra en Windows platform. Dette er muligt og blev også realiseret, men da der blev introduceret eksterne biblioteker til brug i Raspberry Pi, blev det meget svært at få kompileret og inkluderet disse.}

\textit{Derfor blev der valgt en løsning om at bruge Eclipse til Linux. Og da Raspberry Pi kører på en Linux platform, gjorde det tingene meget lettere.}

For at kunne krydskompilere er det nemmeste at bruge en speciel version af Eclipse, som er modificeret til formålet, efter lidt undersøgelser blev der fundet frem til ''Eclipse Kepler Release for C/C++ Developers''\footnote{https://www.eclipse.org/downloads/packages/eclipse-ide-cc-developers/keplerr} og en ''Official Raspbian (armhf) cross compiling toolchain''\footnote{https://github.com/raspberrypi/tools} med kompilere til Raspberry Pi (Raspbian OS). Eclipse skal lige sættes op, så der bruges \verb+arm-linux-gnueabihf-+ som kompiler prefix i projektet.

I ''Remote System Explorer'' i Eclipse laves en ny SSH forbindelse til Raspberry Pi'ens IP, så der fra programmet kan oprettes direkte forbindelse til Raspberry Pi'en. Derefter i Debug Configurations sættes ''Connection'' til den oprettet enhed og stien på Raspberry Pi'en hvori man ønsker at køre sit program fra. I dette tilfæle \verb+/home/pi/Debug/+

\subsubsection*{GPIO}

På Controllerboksen sidder der 2 knapper og 3 LED-dioder, disse skal kunne tilgås fra programmet vha. GPIO benene på Raspberry Pi'en. Der blev hurtigt fundet frem til WiringPi biblioteket\footnote{http://wiringpi.com/} til formålet. Dette er et bibliotek der gør det meget nemt at håndtere GPIO benene på Raspberry Pi'en.

Der blev dog valgt at lave 3 GPIOsocket funktioner der tager sig af at skrive og læse fra det fil arkiv der oprettes når gpio funktionen bliver kaldt. Funktionerne består en \verb+Export+, en \verb+Unexport+ samt en \verb+Direction+ funktion som hhv. opretter og nedlægger et filbibliotek til det ønskede ben på Raspberry Pi'en og sætte retningen på benet (input/output).

\subsubsection*{I2C}

I2C forbindelsen til Vuggesystemet er der også brugt interne funktioner fra WiringPi biblioteket. Der laves et system kald til et script der opretter en I2C forbindelse. Scriptet består af kun 1 linje \verb+gpio load i2c+. På Raspberry Pi Model B, oprettes der en filnode \verb+/dev/i2c-1+ som der benyttes i \verb+I2Csocet+ klassen.

Inspirationen til I2Csocket klassen er taget fra Hertaville bloggen\footnote{http://hertaville.com/2013/04/01/interfacing-an-i2c-gpio-expander-mcp23017-to-the-raspberry-pi-using-c/} der skulle bruges en åben kode, som kunne redigeres om nødvendigt, derfor er klassen blevet oprettet i stedet for at bruge WiringPiI2C.h biblioteket.

\subsubsection*{Mail SMTP}

Mail SMTP er 2 shell scripts der kaldes med et systemkald. Der er ikke noget fejlcheck på ...

\subsubsection*{Netværksstatus}

Baby Watch kræver at der er noget synligt, der indikerer at der er en fejl på netværket, nærmere bestemt internet forbindelsen, da det ikke er muligt at sende en fejl e-mail når internet forbindelsen er afbrudt. Det bliver indikeret af en rød LED på forsiden af Controllerboksen.

For at kontrollere internet forbindelsen er der oprettet en tråd i programkoden der med et interval pinger googles DNS server for svar og returnere \verb+true+ eller \verb+false+ alt efter om der er forbindelse eller ej. For at gøre det ekstra sikkert er der indført en ekstra ping adresse hvis googles DNS ikke svarer, dvs. der er et dobbelttjek på internet forbindelsen.

Der blev undersøgt lidt på hvordan man pinger inde fra et \verb+C+++ program. Løsningen blev at lavet et system kald til den indbyggede \verb+ping+ funktion i Linux. Når der laves et system kald til ping med kommandoen \verb+system("ping -w 2 ip-adresse")+ returneres 0 ved svar og et positivt tal forskellig fra 0 ved intet svar. På den måde er det let kontrollere internet forbindelsen. \verb+-w+ flaget der bliver brugt at en deadline for svar i sekunder, dette er brugt for at undgå at programmet står i unødigt lang tid og prøver at få svar.

\subsubsection*{HTTP Server}

Baby Watch webserveren er er implementeret med en microframework Flask  webserver udviklet af Armin Ronacher(REFERENCE). Servertypen hører under en fri BSD license(REFERENCE) og er igennem sin simple og lette struktur et ideel valg til en webserver integreret på et embedded-system med begrænset CPU-kraft. \\
En Flask webserver består af en python-template der styrer en eller flere html-templates. Igennem python-templaten kan diverse billeder og tekst-strenge styres og opdateres løbende på html siden. Webserveren sørger selv for at sende de nødvendige data til en given bruger(browser) som tilgår websiden. 

\textbf{Beskrivelse af pyhton-templaten og dens funktionaliteter}

\vspace{5mm}

\textbf{Beskrivelse af html-templaten og dens funktionaliteter} \\
En \verb+html+ side består i grove træk af en header og en body. Headeren indeholder definitioner og funktioner som styrer de bagvedlæggende handlinger på hjemmesiden. Body-delen kalder disse definitioner og funktioner til at lave det grafiske interface på hjemmesiden. 
\vspace{1mm} \\
\verb+BabyWatch.html+s header: \\ 
Er implementeret med en overordnet html-funktion som opdaterer hjemmesiden hvert tiende sekund. Herefter defineres fem styles, der henholdvis styrer toppen, bunden, siderne og et centreret billede på hjemmesiden. \\ Eksempel på toppen:  \\
\verb+#header+ \\
    \verb+background-color:lightblue;+\\
    \verb+color:white;+\\
    \verb+text-align:center;+\\
    \verb+padding:5px;+\\
\\Denne style laver et lyseblå felt med hvid skrift. Skriften centres og der paddes med en margin på 5 pixels rundt om feltet. De andre styles er udarbejdet på samme vis.\\
Efter styles bliver der defineret to javascript funktioner, en til at hente klokkeslættet \verb+function startTime()+ og en til at opdatere hjemmesiden med det pågældende klokkeslæt \verb+function checkTime(i)+. Implementeringen på disse kan ses i bilag (REFERENCE)\vspace{2mm}\\
\\ \verb+BabyWatch.html+s body: \\ 
Body'en består af syv divisioner, en til højreside billede, en til toppen, en til bunden, en til klokkeslættet i venstreside, en til klokkeslættet af seneste opdatering af hjemmesiden, en til centerbilledet og en til den tilhørende tekst.\\
\\Eksempel på html-kald af højreside billede: \\
\verb+<div id="rightsection" >+\\
\verb+<img +\\
\verb+src="{{ url_for('static', filename=BabyConState) }}"+\\
\verb+width="100"+\\
\verb+ALT ="BabyCon"+\\
\verb+></img>+\\
\verb+</div>+\\
\\Øverst er et kald til rightsection style. \verb+src+ laver et specielt kald som flaskserver-templaten kan genkende udfra filenavnet \verb+BabyConState+ hvilket indsætter babycon billedet. \verb+Width="100"+ definerer størrelsen på billedet vidde. \verb+ALT = "BabyCon"+ giver et alias til divisionen som kan bruges til debugging af hjemmesiden.\\
\\Eksempel på et html-kald af et java-script:\\
\verb+<div id ="leftsection">+ \\
\verb+<h2>+ \\
\verb+<div id ="txt">+ \\
\\På samme måde som ved eksemplet laves der et kald til leftsection style. Herefter sættes en skriftstørrelse med \verb+<h2>+. Tilsidst kaldes javascript-funktionen der opdaterer med det pågældende tidspunkt vha. \verb+"txt"+.

\textbf{Implemeteringen af webserver funktionerne på Controller}

\verb+initWebServer()+

\verb+stopWebServer()+

\verb+updateToBabyCon1()+

\verb+updateToBabyCon2()+

\verb+updateToBabyCon3()+

\verb+updateFile(int)+
